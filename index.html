<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pitch Frenzy!</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4F46E5;
            --secondary-color: #34D399;
            --background-color: #F3F4F6;
            --game-area-color: #EFF6FF;
            --accent-color: #EC4899;
        }

        body {
            background: linear-gradient(135deg, #1a1c2c 0%, #2a2d4a 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            color: white;
        }

        .game-container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 2rem;
        }

        .game-header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1.5rem;
            padding: 1rem;
        }

        .game-title {
            background: linear-gradient(135deg, #4F46E5 0%, #EC4899 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
            text-align: center;
            font-size: 3.5rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(79, 70, 229, 0.5);
            letter-spacing: 2px;
        }

        .game-area {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 2px 4px rgba(255, 255, 255, 0.1);
            min-height: 600px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .investor {
            position: absolute;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.2);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .investor:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.5);
            border-color: var(--primary-color);
        }

        .face {
            font-size: 2rem;
            transition: transform 0.3s ease;
        }

        .stats-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            margin: 1rem 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: white;
        }

        .timer {
            font-family: 'Monaco', monospace;
            font-size: 1.75rem;
            color: #4F46E5;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(79, 70, 229, 0.5);
        }

        .score {
            font-size: 1.75rem;
            color: #34D399;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(52, 211, 153, 0.5);
        }

        .btn {
            padding: 0.75rem 2rem;
            border-radius: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: none;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.2),
                transparent
            );
            transition: 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4F46E5 0%, #6366F1 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #F59E0B 0%, #F97316 100%);
            color: white;
        }

        .timer-bar-container, .boredom-bar-container {
            position: absolute;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(0, 0, 0, 0.2);
        }

        .timer-bar-container {
            top: 0;
        }

        .boredom-bar-container {
            bottom: 0;
        }

        .timer-bar {
            background: linear-gradient(90deg, #4F46E5 0%, #EC4899 100%);
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.5);
        }

        .boredom-bar {
            background: linear-gradient(90deg, #22C55E 0%, #F59E0B 50%, #EF4444 100%);
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }

        .modal {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.95) !important;
            color: #1a1c2c !important;
        }

        .mic-status {
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
        }

        .mic-status svg {
            filter: drop-shadow(0 0 5px currentColor);
        }

        .game-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .feedback-indicator {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 16px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.8);
            max-width: 300px;
        }

        .modal {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
                        0 10px 10px -5px rgba(0, 0, 0, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.8);
        }

        .boredom-bar {
            background: linear-gradient(90deg, #22C55E 0%, #F59E0B 50%, #EF4444 100%);
            height: 4px;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .timer-bar {
            background: linear-gradient(90deg, #4F46E5 0%, #EC4899 100%);
            height: 4px;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .performance-stats, .improvement-tips {
            color: #1a1c2c !important;
        }

        #performance-stats li, #improvement-tips li {
            color: #374151 !important;
            margin-bottom: 0.5rem;
        }

        .text-primary {
            color: #4F46E5 !important;
        }

        .text-secondary {
            color: #34D399 !important;
        }

        #message-area {
            color: white !important;
            font-size: 1.25rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        #transcript-area {
            color: #E5E7EB !important;
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .stats-container {
            background: rgba(255, 255, 255, 0.15);
        }

        .stat-item {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .timer {
            color: #93C5FD !important;
        }

        .score {
            color: #6EE7B7 !important;
        }

        #ai-feedback-container {
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            z-index: 50;
        }

        #ai-feedback-container.active {
            transform: translateY(0);
        }

        #ai-feedback li {
            padding: 0.5rem;
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.5);
            margin-bottom: 0.5rem;
            border-left: 4px solid;
        }

        #ai-feedback li.positive {
            border-color: #34D399;
            background: rgba(52, 211, 153, 0.1);
        }

        #ai-feedback li.warning {
            border-color: #F59E0B;
            background: rgba(245, 158, 11, 0.1);
        }

        #ai-feedback li.negative {
            border-color: #EF4444;
            background: rgba(239, 68, 68, 0.1);
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="game-container">
        <h1 class="game-title">Pitch Frenzy!</h1>
        
        <div class="game-header">
            <div class="stats-container">
                <div class="stat-item">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-primary"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                    <span class="font-semibold">Time Left:</span>
                    <span id="game-timer" class="timer">03:00</span>
                </div>
                <div class="stat-item">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-secondary"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                    <span class="font-semibold">Score:</span>
                    <span id="score" class="score">0</span>
                </div>
                <div id="mic-status" class="mic-status">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                </div>
            </div>
        </div>

        <div id="game-area" class="game-area"></div>

        <div class="game-controls">
            <button id="start-button" class="btn btn-primary">Start Game</button>
            <button id="pause-button" class="btn btn-secondary" disabled>Pause</button>
        </div>

        <div id="message-area" class="mt-4 text-center text-lg font-medium"></div>
        <div id="transcript-area" class="mt-2 text-center text-gray-600"></div>
        <div id="warning-area" class="mt-2"></div>
        
        <!-- AI Feedback Display -->
        <div id="ai-feedback-container" class="fixed bottom-4 left-4 bg-white bg-opacity-95 p-4 rounded-xl shadow-lg max-w-md">
            <h3 class="text-lg font-semibold text-gray-800 mb-2">AI Speech Analysis</h3>
            <ul id="ai-feedback" class="space-y-2 text-gray-600"></ul>
        </div>
    </div>

    <!-- Rules Modal -->
    <div id="rules-modal" class="modal fixed inset-0 flex items-center justify-center z-50 hidden">
        <div class="modal-backdrop fixed inset-0 bg-black bg-opacity-50"></div>
        <div class="modal-content bg-white p-8 rounded-2xl max-w-2xl mx-4 relative z-10">
            <h2 class="text-2xl font-bold mb-4 text-center text-primary">How to Play Pitch Frenzy!</h2>
            <ul class="list-disc list-inside mb-6 text-gray-700 space-y-2">
                <li><strong>Purpose:</strong> Practice your elevator pitch with mock investors.</li>
                <li><strong>Goal:</strong> Successfully pitch to as many investors (🧐) as possible within the 3-minute time limit.</li>
                <li><strong>Pitching:</strong> Click an investor to start. Speak clearly when the mic icon (🎙️) turns red.</li>
                <li><strong>Time Limit:</strong> Each investor only listens for 30 seconds (⏳).</li>
                <li><strong>Boredom:</strong> Use relevant keywords to keep investors interested. Filler words increase boredom (🟥).</li>
                <li><strong>Success/Failure:</strong> Get a thumbs up (👍) for good pitches, thumbs down (👎) if they get bored.</li>
            </ul>
            <button id="close-rules-button" class="btn btn-primary w-full">Got it!</button>
        </div>
    </div>

    <!-- Game Summary Modal -->
    <div id="summary-modal" class="modal fixed inset-0 flex items-center justify-center z-50 hidden">
        <div class="modal-backdrop fixed inset-0 bg-black bg-opacity-50"></div>
        <div class="modal-content bg-white p-8 rounded-2xl max-w-2xl mx-4 relative z-10">
            <h2 class="text-2xl font-bold mb-4 text-center text-primary">Pitch Frenzy Results!</h2>
            <div class="text-center mb-6">
                <p class="text-xl">You successfully pitched to <span id="successful-pitches" class="font-bold text-secondary">0</span> investors!</p>
                <p class="text-lg">Total Score: <span id="final-score" class="font-bold text-primary">0</span></p>
            </div>
            
            <div class="mb-6">
                <h3 class="font-semibold mb-2">Performance Analysis:</h3>
                <ul id="performance-stats" class="list-disc list-inside text-gray-700"></ul>
            </div>
            
            <div class="mb-6">
                <h3 class="font-semibold mb-2">Improvement Tips:</h3>
                <ul id="improvement-tips" class="list-disc list-inside text-gray-700"></ul>
            </div>

            <div class="border-t border-gray-200 pt-4">
                <h3 class="font-semibold mb-2">Share Your Achievement:</h3>
                <div class="bg-gray-50 p-4 rounded-xl">
                    <p id="share-message" class="text-lg mb-3"></p>
                    <button onclick="copyShareMessage()" class="btn btn-primary w-full">Copy to Clipboard</button>
                </div>
            </div>

            <button id="close-summary-button" class="btn btn-secondary w-full mt-4">Play Again</button>
        </div>
    </div>

    <script>
        console.log("Script execution started.");

        // --- SVG Icons --- (Same as v1.7)
        const MIC_OFF_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="23"/><line x1="8" x2="16" y1="23" y2="23"/></svg>`;
        const MIC_ON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="23"/><line x1="8" x2="16" y1="23" y2="23"/></svg>`;

        // --- Keyword Definitions ---
        const POSITIVE_KEYWORDS = ["market", "growth", "revenue", "solution", "problem", "team", "traction", "unique", "disrupt", "value", "customer", "scale", "profit", "innovate", "strategy", "opportunity", "potential", "competitive", "advantage", "data", "users", "launch", "funding", "build", "develop"];
        // *** Added hmm, hmmm, err ***
        const NEGATIVE_KEYWORDS = ["um", "uh", "like", "basically", "actually", "really", "just", "stuff", "things", "guess", "kinda", "sorta", "hello", "hi", "hmm", "hmmm", "err"];
        const MIN_WORD_COUNT = 10;

        // --- Web Speech API Setup ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        const isSpeechApiAvailable = !!SpeechRecognition;

        // Add browser support check function
        function checkSpeechRecognitionSupport() {
            if (!isSpeechApiAvailable) {
                console.error("Speech Recognition API is not supported in this browser");
                showWarning('speech-api-warning', "Voice input not supported by this browser. Please use Chrome, Edge, or Safari.", 'api-error');
                return false;
            }
            
            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
                console.warn("Speech Recognition requires HTTPS (except on localhost)");
                showWarning('https-warning', 'HTTPS is required for microphone access. Please use a secure connection.', 'https');
                return false;
            }
            
            return true;
        }

        // Add initialization function
        function initializeSpeechRecognition() {
            if (!checkSpeechRecognitionSupport()) {
                return null;
            }

            try {
                const recognitionInstance = new SpeechRecognition();
                recognitionInstance.continuous = true;
                recognitionInstance.interimResults = true;
                recognitionInstance.lang = 'en-US';
                recognitionInstance.maxAlternatives = 1;
                
                return recognitionInstance;
            } catch (error) {
                console.error("Error initializing speech recognition:", error);
                showWarning('speech-api-error', 'Failed to initialize speech recognition. Please try reloading the page.', 'api-error');
                return null;
            }
        }

        let currentPitchAnalysis = { score: 0, words: 0, positive: 0, negative: 0, boredomFactor: 0.2 }; // Store analysis results including factor

        // --- Game Configuration & State ---
        const GAME_DURATION_SECONDS = 180; // 3 minutes
        const PITCH_DURATION_SECONDS = 30;
        const MAX_INVESTORS = 12;
        const INVESTOR_SPAWN_INTERVAL_MS = 3000;
        const VOICE_LISTEN_DURATION_MS = 10000;

        // Dynamic difficulty configuration
        const DIFFICULTY_SCALING = {
            timeThresholds: [
                { remaining: 180, multiplier: 1.0 },    // Start of game
                { remaining: 120, multiplier: 1.2 },    // 2 minutes left
                { remaining: 60, multiplier: 1.5 },     // 1 minute left
                { remaining: 30, multiplier: 2.0 }      // 30 seconds left
            ],
            baseBoredomRate: 0.2,
            maxBoredomRate: 0.8
        };

        // Context keywords for better pitch analysis
        const CONTEXT_KEYWORDS = {
            problem: ["pain point", "challenge", "need", "issue", "difficulty", "gap", "inefficiency"],
            solution: ["solve", "improve", "enhance", "optimize", "streamline", "revolutionize"],
            market: ["target audience", "demographic", "market size", "opportunity", "segment"],
            business: ["revenue", "profit", "monetization", "business model", "pricing"],
            competition: ["competitor", "alternative", "unique", "differentiate", "advantage"],
            traction: ["users", "customers", "growth", "adoption", "retention"],
            team: ["experience", "expertise", "background", "skilled", "passionate"]
        };

        // Add to existing pitch analysis
        function analyzePitchContext(transcript) {
            const contextScores = {};
            const words = transcript.toLowerCase().split(/\s+/);
            
            // Score each context category
            for (const [category, keywords] of Object.entries(CONTEXT_KEYWORDS)) {
                contextScores[category] = keywords.reduce((score, keyword) => {
                    const regex = new RegExp(keyword, 'gi');
                    const matches = transcript.match(regex) || [];
                    return score + matches.length;
                }, 0);
            }
            
            // Calculate completeness of pitch
            const coveredCategories = Object.values(contextScores).filter(score => score > 0).length;
            const completenessScore = coveredCategories / Object.keys(CONTEXT_KEYWORDS).length;
            
            return {
                contextScores,
                completenessScore,
                missingElements: Object.entries(contextScores)
                    .filter(([_, score]) => score === 0)
                    .map(([category]) => category)
            };
        }

        function calculateBoredomFactor(analysis) {
            // Get current difficulty multiplier based on time remaining
            const currentMultiplier = DIFFICULTY_SCALING.timeThresholds.reduce((mult, threshold) => {
                return gameTimeLeft <= threshold.remaining ? threshold.multiplier : mult;
            }, 1.0);
            
            // Start with base factor
            let factor = DIFFICULTY_SCALING.baseBoredomRate * currentMultiplier;
            
            // Analyze context and adjust factor
            if (analysis.words > 0) {
                const contextAnalysis = analyzePitchContext(DOM.transcriptArea.textContent || '');
                
                // Reduce boredom if pitch is more complete
                factor *= (1 - contextAnalysis.completenessScore * 0.3);
                
                // Increase factor if using too many filler words
                if (analysis.negative > 0) {
                    factor += 0.1 * (analysis.negative / analysis.words) * currentMultiplier;
                }
                
                // Decrease factor if using business terms effectively
                if (analysis.positive > 0) {
                    factor -= 0.05 * (analysis.positive / analysis.words);
                }
            }
            
            // Ensure factor stays within reasonable bounds, scaled by current difficulty
            const maxRate = DIFFICULTY_SCALING.maxBoredomRate * currentMultiplier;
            return Math.max(0.1, Math.min(maxRate, factor));
        }

        // Update the feedback display to show context analysis
        function updateFeedbackDisplay(analysis) {
            const feedbackIndicator = document.getElementById('feedbackIndicator');
            if (!feedbackIndicator) return;
            
            const contextAnalysis = analyzePitchContext(DOM.transcriptArea.textContent || '');
            const missingContext = contextAnalysis.missingElements;
            
            feedbackIndicator.classList.remove('hidden');
            
            // Show real-time feedback based on context
            let feedback = '';
            if (missingContext.length > 0) {
                feedback = `Try addressing: ${missingContext.join(', ')}`;
            } else if (contextAnalysis.completenessScore < 0.5) {
                feedback = "Expand on your key points";
            } else if (analysis.negative > analysis.positive) {
                feedback = "Use more business terms, fewer filler words";
            } else {
                feedback = "Good pitch structure!";
            }
            
            const realTimeFeedback = document.getElementById('realTimeFeedback');
            if (realTimeFeedback) {
                realTimeFeedback.textContent = feedback;
                realTimeFeedback.className = contextAnalysis.completenessScore > 0.7 ? "success" : "warning";
            }
        }

        const DOM = {
            gameTimer: document.getElementById('game-timer'),
            scoreDisplay: document.getElementById('score'),
            gameArea: document.getElementById('game-area'),
            messageArea: document.getElementById('message-area'),
            micStatus: document.getElementById('mic-status'),
            transcriptArea: document.getElementById('transcript-area'),
            warningArea: document.getElementById('warning-area'),
            rulesModal: document.getElementById('rules-modal'),
            closeRulesButton: document.getElementById('close-rules-button'),
            startButton: document.getElementById('start-button'),
            pauseButton: document.getElementById('pause-button'),
            pitchButton: document.getElementById('pitch-now-button'),
            summaryModal: document.getElementById('summary-modal'),
            closeSummaryButton: document.getElementById('close-summary-button'),
            successfulPitchesDisplay: document.getElementById('successful-pitches'),
            finalScoreDisplay: document.getElementById('final-score'),
            performanceStats: document.getElementById('performance-stats'),
            improvementTips: document.getElementById('improvement-tips')
        };

        // Game state variables
        let isGameRunning = false;
        let gameTimeLeft = GAME_DURATION_SECONDS;
        let score = 0;
        let currentPitch = null;
        let isPaused = false;
        let investors = [];
        let gameIntervalId = null;
        let investorSpawnIntervalId = null;
        let isListening = false;
        let rulesShown = false;
        const INVESTOR_DEFAULT_FACE = '🧐';
        
        // Game statistics tracking
        let gameStats = {
            totalPitches: 0,
            successfulPitches: 0,
            failedPitches: 0,
            averageScore: 0,
            totalScore: 0,
            pitchAnalysis: {
                tooSlow: 0,
                tooFast: 0,
                highFillerWords: 0,
                lowKeywordDensity: 0,
                repetitivePhrases: 0,
                consecutiveFillers: 0
            },
            pitchScores: [],
            avgPitchScore: 0
        };

        // Initialize transcript variable
        let currentTranscript = '';

        // Update initial display
        document.addEventListener('DOMContentLoaded', function() {
            if (DOM.gameTimer) DOM.gameTimer.textContent = "03:00";
            updateScoreDisplay();
        });

        function resetGame() {
            stopAllPitches();
            gameTimeLeft = GAME_DURATION_SECONDS;
            score = 0;
            currentPitch = null;
            isGameRunning = false;
            if (DOM.gameTimer) DOM.gameTimer.textContent = "03:00";
            updateScoreDisplay();
            clearAllInvestors();
            gameStats = createInitialGameStats();
        }

        // --- Functions --- (formatTime, updateGameTimerDisplay, updateScoreDisplay, showMessage, clearMessage, updateMicStatus, showWarning, clearWarning, showRulesModal, hideRulesModal - same as v1.8)
        function formatTime(totalSeconds) { const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
        function updateGameTimerDisplay() { DOM.gameTimer.textContent = formatTime(gameTimeLeft); }
        function updateScoreDisplay() { DOM.scoreDisplay.textContent = score; }
        function showMessage(msg, isError = false, persist = false) { if (!DOM.messageArea) { console.error("Debug: messageArea not found!"); return; } DOM.messageArea.textContent = msg; DOM.messageArea.style.color = isError ? '#dc2626' : '#374151'; if (!isError && !persist) { setTimeout(() => { if (DOM.messageArea.textContent === msg) DOM.messageArea.textContent = ''; }, 3000); } }
        function clearMessage() { if (DOM.messageArea) DOM.messageArea.textContent = ''; if (DOM.transcriptArea) DOM.transcriptArea.textContent = ''; }
        function updateMicStatus(status) {
            if (!DOM.micStatus) {
                console.error("Debug: micStatus element not found!");
                return;
            }
            console.log("Debug: Updating mic status to:", status);
            let svg = MIC_OFF_SVG;
            let colorClass = 'text-gray-400';
            let pitchButton = document.getElementById('pitch-now-button');
            
            switch (status) {
                case 'listening':
                    svg = MIC_ON_SVG;
                    colorClass = 'text-red-500 bg-red-100';
                    if (pitchButton) pitchButton.classList.remove('hidden');
                    break;
                case 'processing':
                    svg = MIC_ON_SVG;
                    colorClass = 'text-blue-500 bg-blue-100';
                    if (pitchButton) pitchButton.classList.add('hidden');
                    break;
                case 'error':
                    svg = MIC_OFF_SVG;
                    colorClass = 'text-red-500 bg-red-100';
                    if (pitchButton) pitchButton.classList.add('hidden');
                    break;
                case 'idle':
                default:
                    svg = MIC_OFF_SVG;
                    colorClass = 'text-gray-400 bg-gray-200';
                    if (pitchButton) pitchButton.classList.add('hidden');
                    break;
            }
            DOM.micStatus.innerHTML = svg;
            DOM.micStatus.className = `flex items-center justify-center w-10 h-10 rounded-full ${colorClass}`;
        }
        function showWarning(id, text, type = 'api-error') { if (!DOM.warningArea) return; const existing = document.getElementById(id); if (existing) existing.remove(); const warning = document.createElement('p'); warning.id = id; warning.textContent = text; warning.className = type === 'https' ? 'debug-warning' : 'api-error-warning'; DOM.warningArea.appendChild(warning); }
        function clearWarning(id) { const existing = document.getElementById(id); if (existing) existing.remove(); }
        function showRulesModal() { if (DOM.rulesModal) { DOM.rulesModal.classList.remove('hidden'); } }
        function hideRulesModal() { if (DOM.rulesModal) { DOM.rulesModal.classList.add('hidden'); } }

        function updateGameStats(pitchAnalysis, success) {
            gameStats.totalPitches++;
            if (success) gameStats.successfulPitches++;
            else gameStats.failedPitches++;
            
            gameStats.totalScore += pitchAnalysis.score;
            gameStats.averageScore = gameStats.totalScore / gameStats.totalPitches;

            // Track specific issues
            const wordsPerMinute = (pitchAnalysis.words / (pitchAnalysis.duration || 30)) * 60;
            if (wordsPerMinute < 100) gameStats.pitchAnalysis.tooSlow++;
            if (wordsPerMinute > 180) gameStats.pitchAnalysis.tooFast++;
            
            const fillerRatio = pitchAnalysis.negative / pitchAnalysis.words;
            if (fillerRatio > 0.15) gameStats.pitchAnalysis.highFillerWords++;
            
            const keywordDensity = pitchAnalysis.positive / pitchAnalysis.words;
            if (keywordDensity < 0.1) gameStats.pitchAnalysis.lowKeywordDensity++;
            
            if (pitchAnalysis.repetitionPenalty > 1) gameStats.pitchAnalysis.repetitivePhrases++;
            if (pitchAnalysis.maxConsecutiveFillerWords >= 3) gameStats.pitchAnalysis.consecutiveFillers++;

            // Store pitch quality metrics
            if (pitchAnalysis) {
                gameStats.pitchScores.push(pitchAnalysis.score);
                gameStats.avgPitchScore = gameStats.pitchScores.reduce((a, b) => a + b, 0) / gameStats.pitchScores.length;
            }
        }

        function showGameSummary() {
            // Update summary displays with correct values
            DOM.successfulPitchesDisplay.textContent = gameStats.successfulPitches;
            DOM.finalScoreDisplay.textContent = calculateFinalScore();

            // Update share message with correct values
            const shareMessage = document.getElementById('share-message');
            if (shareMessage) {
                shareMessage.textContent = `🎯 I pitched ${gameStats.totalPitches} investors and scored ${calculateFinalScore()} points in Pitch Frenzy! Think you can beat my score? 🚀 #PitchFrenzy`;
            }

            // Clear previous stats
            DOM.performanceStats.innerHTML = '';
            DOM.improvementTips.innerHTML = '';

            // Add performance statistics
            const stats = [
                `Total Pitches: ${gameStats.totalPitches}`,
                `Successful Pitches: ${gameStats.successfulPitches}`,
                `Success Rate: ${((gameStats.successfulPitches / gameStats.totalPitches) * 100).toFixed(1)}%`,
                `Average Pitch Score: ${gameStats.avgPitchScore.toFixed(1)}`
            ];
            stats.forEach(stat => {
                const li = document.createElement('li');
                li.textContent = stat;
                DOM.performanceStats.appendChild(li);
            });

            // Generate improvement tips based on statistics
            generateImprovementTips();

            // Show the summary modal
            DOM.summaryModal.classList.remove('hidden');
        }

        function calculateFinalScore() {
            // Base score from successful pitches (50 points each)
            const successScore = gameStats.successfulPitches * 50;
            
            // Bonus points from average pitch quality (-5 to +5 points per pitch)
            const qualityBonus = Math.round(gameStats.avgPitchScore * gameStats.totalPitches * 10);
            
            // Speed bonus (more pitches attempted = higher bonus)
            const speedBonus = Math.round(gameStats.totalPitches * 5);
            
            // Success rate bonus (up to 100 bonus points for high success rate)
            const successRate = gameStats.successfulPitches / gameStats.totalPitches;
            const successRateBonus = Math.round(successRate * 100);
            
            const totalScore = Math.max(0, successScore + qualityBonus + speedBonus + successRateBonus);
            
            console.log(`Score Breakdown:
                Success Score (${gameStats.successfulPitches} × 50): ${successScore}
                Quality Bonus (avg ${gameStats.avgPitchScore.toFixed(1)}): ${qualityBonus}
                Speed Bonus (${gameStats.totalPitches} pitches): ${speedBonus}
                Success Rate Bonus (${(successRate * 100).toFixed(1)}%): ${successRateBonus}
                Total: ${totalScore}`);
            
            return totalScore;
        }

        function endPitch(investorData, success, message) {
            if (!investorData || !investorData.isBeingPitched) return;
            stopRecognition();
            clearInterval(investorData.pitchTimerId);
            clearInterval(investorData.boredomTimerId);
            investorData.pitchTimerId = null;
            investorData.boredomTimerId = null;
            investorData.isBeingPitched = false;
            investorData.hasBeenPitched = true;
            currentPitch = null;
            investorData.element.style.outline = 'none';
            const faceSpan = investorData.element.querySelector('.face');
            if (faceSpan) faceSpan.style.transform = 'rotateY(0deg)';
            
            // Update game statistics
            updateGameStats(currentPitchAnalysis, success);
            
            if (success) {
                score = calculateFinalScore(); // Update the score based on all factors
                updateScoreDisplay();
                showMessage("👍 Great pitch! Click another investor to continue.", false);
                if (faceSpan) faceSpan.textContent = '👍';
                investorData.element.style.backgroundColor = '#4ade80';
                setTimeout(() => removeInvestor(investorData), 2000);
            } else {
                if (isGameRunning) {
                    const failMessage = message.includes("Lost interest") ? 
                        "👎 Bored! Click another investor to try again." : 
                        "⏰ Time's up! Click another investor to try again.";
                    showMessage(failMessage, true);
                }
                if (faceSpan) faceSpan.textContent = message.includes("Lost interest") ? '👎' : '⏰';
                investorData.element.style.backgroundColor = '#f87171';
                setTimeout(() => removeInvestor(investorData), 2000);
            }
            
            // Update the score display
            score = calculateFinalScore();
            updateScoreDisplay();
            
            setTimeout(() => {
                if (DOM.transcriptArea) DOM.transcriptArea.innerHTML = '';
            }, 1500);
        }

        function removeInvestor(investorData) {
            console.log("Removing investor...");
            if (investorData.pitchTimerId) clearInterval(investorData.pitchTimerId);
            if (investorData.boredomTimerId) clearInterval(investorData.boredomTimerId);
            if (investorData.element && investorData.element.parentNode === DOM.gameArea) {
                DOM.gameArea.removeChild(investorData.element);
            }
            investors = investors.filter(inv => inv.id !== investorData.id);
            console.log("Investor removed. Remaining investors:", investors.length);
            if (isGameRunning && !isPaused && investors.length < MAX_INVESTORS / 2) {
                console.log("Scheduling new investor creation...");
                setTimeout(createInvestor, 1000);
            }
        }

        function endGame() {
            stopRecognition();
            isGameRunning = false;
            isPaused = false;
            clearInterval(gameIntervalId);
            clearInterval(investorSpawnIntervalId);
            gameIntervalId = null;
            investorSpawnIntervalId = null;
            if (currentPitch && currentPitch.isBeingPitched) {
                endPitch(currentPitch, false, "Game Over!");
            }
            currentPitch = null;
            investors.forEach(inv => {
                if(inv.element) inv.element.style.cursor = 'default';
            });
            showMessage(`Game Over! Final Score: ${score}`, false, true);
            DOM.startButton.disabled = false;
            DOM.pauseButton.disabled = true;
            DOM.pauseButton.textContent = 'Pause';
            DOM.pauseButton.classList.remove('bg-green-500', 'hover:bg-green-700');
            DOM.pauseButton.classList.add('bg-yellow-500', 'hover:bg-yellow-700');
            DOM.startButton.textContent = "Play Again?";
            updateMicStatus('idle');
            
            // Show the game summary
            showGameSummary();
        }

        function startGame() {
            console.log("Debug: startGame called.");
            if (isGameRunning) return;
            
            if (!rulesShown) {
                showRulesModal();
                rulesShown = true;
                return;
            }
            
            // Reset game state
            score = 0;
            gameTimeLeft = GAME_DURATION_SECONDS;
            isGameRunning = true;
            isPaused = false;
            currentPitch = null;
            
            // Update UI
            updateScoreDisplay();
            updateGameTimerDisplay();
            DOM.startButton.disabled = true;
            DOM.pauseButton.disabled = false;
            DOM.pauseButton.textContent = 'Pause';
            DOM.pauseButton.classList.remove('bg-green-500', 'hover:bg-green-700');
            DOM.pauseButton.classList.add('bg-yellow-500', 'hover:bg-yellow-700');
            
            // Clear messages and update status
            clearMessage();
            updateMicStatus('idle');
            clearWarning('https-warning');
            clearWarning('speech-api-warning');
            
            // Check HTTPS
            if (window.location.protocol !== 'https:') {
                console.warn("Debug: Page is not loaded over HTTPS.");
                showWarning('https-warning', 'Warning: Page is not HTTPS. Microphone access might be blocked by the browser.', 'https');
            }
            
            // Check Speech API
            if (!isSpeechApiAvailable) {
                console.warn("Debug: Speech API IS NOT available.");
                showWarning('speech-api-warning', "Voice input not supported by browser.", 'api-error');
            }
            
            // Clear existing investors
            investors.forEach(inv => {
                if (inv.element && inv.element.parentNode) {
                    inv.element.parentNode.removeChild(inv.element);
                }
            });
            investors = [];
            
            // Start game timer
            gameIntervalId = setInterval(() => {
                if (!isPaused) {
                    gameTimeLeft--;
                    updateGameTimerDisplay();
                    if (gameTimeLeft <= 0) endGame();
                }
            }, 1000);
            
            // Create initial investors
            for (let i = 0; i < MAX_INVESTORS / 2; i++) {
                createInvestor();
            }
            
            // Start spawning new investors
            investorSpawnIntervalId = setInterval(createInvestor, INVESTOR_SPAWN_INTERVAL_MS);
        }

        function togglePause() {
            if (!isGameRunning) return;
            
            isPaused = !isPaused;
            console.log("Game paused:", isPaused);
            
            if (isPaused) {
                // Pause game
                stopRecognition();
                clearInterval(gameIntervalId);
                clearInterval(investorSpawnIntervalId);
                
                // Stop all active timers
                investors.forEach(inv => {
                    if (inv.pitchTimerId) clearInterval(inv.pitchTimerId);
                    if (inv.boredomTimerId) clearInterval(inv.boredomTimerId);
                });
                
                gameIntervalId = null;
                investorSpawnIntervalId = null;
                
                // Update UI
                DOM.pauseButton.textContent = 'Resume';
                DOM.pauseButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-700');
                DOM.pauseButton.classList.add('bg-green-500', 'hover:bg-green-700');
                showMessage('Game Paused');
            } else {
                if (gameTimeLeft > 0) {
                    // Resume game timer
                    gameIntervalId = setInterval(() => {
                        gameTimeLeft--;
                        updateGameTimerDisplay();
                        if (gameTimeLeft <= 0) endGame();
                    }, 1000);
                    
                    // Resume investor spawning
                    investorSpawnIntervalId = setInterval(createInvestor, INVESTOR_SPAWN_INTERVAL_MS);
                    
                    // Resume active pitch timers
                    investors.forEach(inv => {
                        if (inv.isBeingPitched) {
                            // Resume pitch timer
                            inv.pitchTimerId = setInterval(() => {
                                if (isPaused || !inv.isBeingPitched) return;
                                inv.pitchTimeLeft--;
                                const timerWidth = (inv.pitchTimeLeft / PITCH_DURATION_SECONDS) * 100;
                                const timerBar = inv.element.querySelector('.timer-bar');
                                if(timerBar) timerBar.style.width = `${Math.max(0, timerWidth)}%`;
                                
                                if (inv.pitchTimeLeft <= 0) {
                                    endPitch(inv, false, "Time's up!");
                                }
                            }, 1000);
                            
                            // Resume boredom timer
                            startBoredomTimer(inv);
                        }
                    });
                    
                    // Update UI
                    DOM.pauseButton.textContent = 'Pause';
                    DOM.pauseButton.classList.remove('bg-green-500', 'hover:bg-green-700');
                    DOM.pauseButton.classList.add('bg-yellow-500', 'hover:bg-yellow-700');
                    showMessage('Game Resumed');
                } else {
                    isPaused = true;
                    showMessage('Cannot resume, time is up!', true);
                }
            }
        }

        /** Stop speech recognition */
        function stopRecognition() {
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.error("Error stopping recognition:", e);
                }
                recognition = null;
            }
            isListening = false;
            updateMicStatus('idle');
        }

        // Advanced AI Voice Analysis Configuration
        const VOICE_ANALYSIS = {
            sentiment: {
                positive: ["confident", "enthusiastic", "professional"],
                negative: ["uncertain", "monotone", "hesitant"]
            },
            clarity: {
                minWordsPerMinute: 120,
                maxWordsPerMinute: 160,
                optimalPauseDuration: 0.5 // seconds
            },
            tone: {
                pitchRange: {
                    min: 75,  // Hz
                    max: 300  // Hz
                },
                volumeRange: {
                    min: -30, // dB
                    max: -10  // dB
                }
            },
            semantics: {
                structureElements: ["introduction", "problem", "solution", "market", "ask"],
                transitionPhrases: ["moreover", "however", "specifically", "in addition", "therefore"]
            }
        };

        // Enhanced pitch analysis with AI features
        async function analyzeVoiceWithAI(audioData, transcript) {
            try {
                // Create AudioContext for real-time audio analysis
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(audioData);
                source.connect(analyser);

                // Analyze voice characteristics
                const voiceMetrics = await analyzeVoiceMetrics(analyser);
                
                // Analyze speech patterns
                const speechPatterns = analyzeSpeechPatterns(transcript);
                
                // Calculate confidence score
                const confidenceScore = calculateConfidenceScore(voiceMetrics, speechPatterns);
                
                return {
                    metrics: voiceMetrics,
                    patterns: speechPatterns,
                    confidence: confidenceScore
                };
            } catch (error) {
                console.error("Error in AI voice analysis:", error);
                return null;
            }
        }

        function analyzeVoiceMetrics(analyser) {
            return new Promise((resolve) => {
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Float32Array(bufferLength);
                
                analyser.getFloatTimeDomainData(dataArray);
                
                // Calculate voice metrics
                const metrics = {
                    pitch: calculatePitch(dataArray),
                    volume: calculateVolume(dataArray),
                    clarity: calculateClarity(dataArray),
                    rhythm: analyzeRhythm(dataArray)
                };
                
                resolve(metrics);
            });
        }

        function analyzeSpeechPatterns(transcript) {
            const words = transcript.toLowerCase().split(/\s+/);
            const patterns = {
                pacing: calculatePacing(words),
                structure: analyzeStructure(transcript),
                transitions: findTransitions(transcript),
                emphasis: detectEmphasis(transcript)
            };
            
            return patterns;
        }

        function calculateConfidenceScore(metrics, patterns) {
            let score = 0;
            
            // Voice metrics scoring (0-40 points)
            if (metrics) {
                // Pitch variation (0-10 points)
                const pitchScore = Math.min(10, 
                    (metrics.pitch.variation / VOICE_ANALYSIS.tone.pitchRange.max) * 10
                );
                score += pitchScore;
                
                // Volume control (0-10 points)
                const volumeScore = Math.min(10,
                    ((metrics.volume - VOICE_ANALYSIS.tone.volumeRange.min) / 
                    (VOICE_ANALYSIS.tone.volumeRange.max - VOICE_ANALYSIS.tone.volumeRange.min)) * 10
                );
                score += volumeScore;
                
                // Clarity (0-10 points)
                score += metrics.clarity * 10;
                
                // Rhythm (0-10 points)
                score += metrics.rhythm * 10;
            }
            
            // Speech patterns scoring (0-60 points)
            if (patterns) {
                // Pacing (0-15 points)
                score += patterns.pacing * 15;
                
                // Structure (0-15 points)
                score += patterns.structure * 15;
                
                // Transitions (0-15 points)
                score += patterns.transitions * 15;
                
                // Emphasis (0-15 points)
                score += patterns.emphasis * 15;
            }
            
            return Math.min(100, score) / 100; // Normalize to 0-1
        }

        // Update the startPitch function to use AI analysis
        function startPitch(investorData) {
            console.log("Starting pitch...");
            
            // Initialize pitch state
            currentPitch = investorData;
            investorData.isBeingPitched = true;
            investorData.pitchTimeLeft = PITCH_DURATION_SECONDS;
            currentTranscript = '';
            currentPitchAnalysis = { score: 0, words: 0, positive: 0, negative: 0, boredomFactor: 0.2 };
            
            // Update UI
            investorData.element.style.outline = '2px solid #4F46E5';
            const faceSpan = investorData.element.querySelector('.face');
            if (faceSpan) faceSpan.style.transform = 'rotateY(180deg)';
            
            // Initialize speech recognition
            try {
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                recognition.maxAlternatives = 1;
                
                recognition.onstart = () => {
                    console.log("Speech recognition started");
                    isListening = true;
                    updateMicStatus('listening');
                    showMessage("Start your pitch now!", false);
                };
                
                recognition.onresult = async (event) => {
                    const transcript = Array.from(event.results)
                        .map(result => result[0].transcript)
                        .join('');
                    
                    if (DOM.transcriptArea) {
                        DOM.transcriptArea.textContent = transcript;
                    }
                    
                    // Get audio stream for AI analysis
                    if (recognition.audioStream) {
                        const aiAnalysis = await analyzeVoiceWithAI(recognition.audioStream, transcript);
                        if (aiAnalysis) {
                            // Update boredom factor based on AI analysis
                            const aiConfidenceBonus = aiAnalysis.confidence * 0.3; // Up to 30% reduction in boredom
                            investorData.boredomIncrementFactor *= (1 - aiConfidenceBonus);
                            
                            // Update feedback display with AI insights
                            updateAIFeedback(aiAnalysis);
                        }
                    }
                    
                    // Existing pitch analysis code...
                    const words = transcript.toLowerCase().split(/\s+/);
                    const positiveCount = words.filter(word => POSITIVE_KEYWORDS.includes(word)).length;
                    const negativeCount = words.filter(word => NEGATIVE_KEYWORDS.includes(word)).length;
                    
                    currentPitchAnalysis = {
                        score: calculatePitchScore(positiveCount, negativeCount, words.length),
                        words: words.length,
                        positive: positiveCount,
                        negative: negativeCount,
                        duration: PITCH_DURATION_SECONDS - investorData.pitchTimeLeft,
                        aiMetrics: aiAnalysis
                    };
                    
                    investorData.boredomIncrementFactor = calculateBoredomFactor(currentPitchAnalysis);
                };
                
                recognition.onerror = (event) => {
                    console.error("Speech recognition error:", event.error);
                    updateMicStatus('error');
                    showMessage("Microphone error! Click the investor again to retry.", true);
                    endPitch(investorData, false, "Technical difficulties!");
                };
                
                recognition.onend = () => {
                    console.log("Speech recognition ended");
                    if (isListening && currentPitch === investorData) {
                        try {
                            recognition.start();
                        } catch (e) {
                            console.error("Error restarting recognition:", e);
                        }
                    }
                };
                
                recognition.start();
                
                // Start pitch timer
                investorData.pitchTimerId = setInterval(() => {
                    if (isPaused || !investorData.isBeingPitched) return;
                    
                    investorData.pitchTimeLeft--;
                    const timerWidth = (investorData.pitchTimeLeft / PITCH_DURATION_SECONDS) * 100;
                    const timerBar = investorData.element.querySelector('.timer-bar');
                    if (timerBar) timerBar.style.width = `${Math.max(0, timerWidth)}%`;
                    
                    if (investorData.pitchTimeLeft <= 0) {
                        const transcript = DOM.transcriptArea?.textContent || '';
                        const words = transcript.toLowerCase().split(/\s+/);
                        const positiveCount = words.filter(word => POSITIVE_KEYWORDS.includes(word)).length;
                        const negativeCount = words.filter(word => NEGATIVE_KEYWORDS.includes(word)).length;
                        
                        // Check if pitch meets quality criteria
                        const isQualityPitch = 
                            words.length >= MINIMUM_WORDS_FOR_SUCCESS && // Minimum word count
                            positiveCount >= MINIMUM_BUSINESS_TERMS && // Enough business terms
                            (negativeCount / words.length) <= MAXIMUM_FILLER_RATIO && // Not too many fillers
                            investorData.boredomLevel < 100; // Not completely bored
                        
                        endPitch(investorData, isQualityPitch, 
                            isQualityPitch ? "Great pitch!" : 
                            words.length < MINIMUM_WORDS_FOR_SUCCESS ? "Too brief!" :
                            positiveCount < MINIMUM_BUSINESS_TERMS ? "Need more business context!" :
                            "Not engaging enough!");
                    }
                }, 1000);
                
                // Start boredom timer
                startBoredomTimer(investorData);
                
            } catch (error) {
                console.error("Error starting speech recognition:", error);
                showMessage("Failed to start microphone! Click the investor again to retry.", true);
                endPitch(investorData, false, "Technical difficulties!");
            }
        }

        function updateAIFeedback(aiAnalysis) {
            const feedbackArea = document.getElementById('ai-feedback');
            if (!feedbackArea) return;
            
            const metrics = aiAnalysis.metrics;
            const patterns = aiAnalysis.patterns;
            
            let feedback = [];
            
            // Voice quality feedback
            if (metrics.pitch.variation < VOICE_ANALYSIS.tone.pitchRange.min) {
                feedback.push("Try varying your tone more to engage the investor");
            }
            if (metrics.volume < VOICE_ANALYSIS.tone.volumeRange.min) {
                feedback.push("Speak up a bit to show confidence");
            }
            if (metrics.clarity < 0.7) {
                feedback.push("Focus on clear pronunciation");
            }
            
            // Speech pattern feedback
            if (patterns.pacing < 0.6) {
                feedback.push("Adjust your speaking pace - aim for 120-160 words per minute");
            }
            if (patterns.structure < 0.5) {
                feedback.push("Structure your pitch with clear sections");
            }
            if (patterns.transitions < 0.4) {
                feedback.push("Use transition phrases to connect your ideas");
            }
            
            feedbackArea.innerHTML = feedback.map(f => `<li>${f}</li>`).join('');
        }

        function calculatePitchScore(positiveCount, negativeCount, totalWords) {
            if (totalWords < MIN_WORD_COUNT) return 0;
            
            const positiveRatio = positiveCount / totalWords;
            const negativeRatio = negativeCount / totalWords;
            
            // Base score from 0 to 1
            let score = Math.min(1, positiveRatio * 2) - Math.min(1, negativeRatio * 3);
            
            // Normalize to 0-1 range
            score = Math.max(0, Math.min(1, (score + 1) / 2));
            
            return score;
        }

        // Add these constants near the other game configuration constants
        const MINIMUM_WORDS_FOR_SUCCESS = 30; // Minimum words needed for a successful pitch
        const MINIMUM_BUSINESS_TERMS = 3;     // Minimum number of business/positive terms needed
        const MAXIMUM_FILLER_RATIO = 0.15;    // Maximum allowed ratio of filler words
        const SILENCE_PENALTY = 0.5;          // How much to increase boredom during silence

        function startBoredomTimer(investorData) {
            if (investorData.boredomTimerId) clearInterval(investorData.boredomTimerId);
            
            // Track silence and speech quality
            let lastTranscriptLength = 0;
            let silenceCounter = 0;
            let lastWordCount = 0;
            const SILENCE_THRESHOLD = 8; // 800ms of silence before increasing boredom
            const GRACE_PERIOD = 20; // 2 seconds grace period at start
            let gracePeriodCounter = 0;
            
            // Set initial boredom increment to be more forgiving
            investorData.boredomIncrementFactor = 0.15;
            
            investorData.boredomTimerId = setInterval(() => {
                if (isPaused || !investorData.isBeingPitched) return;
                
                // Grace period at the start
                if (gracePeriodCounter < GRACE_PERIOD) {
                    gracePeriodCounter++;
                    return;
                }
                
                // Check for silence by comparing transcript length
                const transcript = DOM.transcriptArea?.textContent || '';
                const currentTranscriptLength = transcript.length;
                const currentWordCount = transcript.split(/\s+/).length;
                
                // Detect silence or very slow speech
                if (currentTranscriptLength === lastTranscriptLength || currentWordCount === lastWordCount) {
                    silenceCounter++;
                    if (silenceCounter >= SILENCE_THRESHOLD) {
                        // Significant increase in boredom during silence
                        investorData.boredomLevel += SILENCE_PENALTY;
                    }
                } else {
                    silenceCounter = Math.max(0, silenceCounter - 2); // Reduce silence counter when speaking
                    // Analyze speech quality in real-time
                    const words = transcript.toLowerCase().split(/\s+/);
                    const positiveCount = words.filter(word => POSITIVE_KEYWORDS.includes(word)).length;
                    const negativeCount = words.filter(word => NEGATIVE_KEYWORDS.includes(word)).length;
                    
                    // Adjust boredom based on speech quality
                    if (negativeCount / words.length > MAXIMUM_FILLER_RATIO) {
                        investorData.boredomIncrementFactor = 0.3; // Increase boredom for too many fillers
                    } else if (positiveCount >= MINIMUM_BUSINESS_TERMS) {
                        investorData.boredomIncrementFactor = 0.1; // Reduce boredom for good content
                    }
                }
                
                lastTranscriptLength = currentTranscriptLength;
                lastWordCount = currentWordCount;
                
                // Increase boredom level
                investorData.boredomLevel += investorData.boredomIncrementFactor;
                const boredomBar = investorData.element.querySelector('.boredom-bar');
                if (boredomBar) boredomBar.style.width = `${Math.min(100, investorData.boredomLevel)}%`;
                
                if (investorData.boredomLevel >= 100) {
                    endPitch(investorData, false, "Lost interest!");
                }
            }, 100);
        }

        function clearAllInvestors() {
            investors.forEach(inv => {
                if (inv.pitchTimerId) clearInterval(inv.pitchTimerId);
                if (inv.boredomTimerId) clearInterval(inv.boredomTimerId);
                if (inv.element && inv.element.parentNode) {
                    inv.element.parentNode.removeChild(inv.element);
                }
            });
            investors = [];
        }

        function stopAllPitches() {
            if (currentPitch) {
                endPitch(currentPitch, false, "Game stopped");
            }
            investors.forEach(inv => {
                if (inv.pitchTimerId) clearInterval(inv.pitchTimerId);
                if (inv.boredomTimerId) clearInterval(inv.boredomTimerId);
            });
            stopRecognition();
        }

        function generateImprovementTips() {
            const tips = [];
            
            if (gameStats.pitchAnalysis.tooSlow > 0) {
                tips.push("Try to speak more quickly to engage investors better.");
            }
            if (gameStats.pitchAnalysis.tooFast > 0) {
                tips.push("Slow down a bit to ensure clarity in your pitch.");
            }
            if (gameStats.pitchAnalysis.highFillerWords > 0) {
                tips.push("Reduce filler words like 'um', 'uh', and 'like' to sound more confident.");
            }
            if (gameStats.pitchAnalysis.lowKeywordDensity > 0) {
                tips.push("Include more business terms and industry keywords in your pitch.");
            }
            if (gameStats.pitchAnalysis.repetitivePhrases > 0) {
                tips.push("Vary your vocabulary to keep investors engaged.");
            }
            if (gameStats.pitchAnalysis.consecutiveFillers > 0) {
                tips.push("Work on smoother transitions between ideas to avoid consecutive filler words.");
            }
            
            // Add general tips if needed
            if (tips.length === 0) {
                tips.push("Great job! Keep practicing to maintain your pitch quality.");
                tips.push("Try increasing your pitch speed to reach more investors.");
            }
            
            // Add tips to the DOM
            tips.forEach(tip => {
                const li = document.createElement('li');
                li.textContent = tip;
                DOM.improvementTips.appendChild(li);
            });
        }

        function hideGameSummary() {
            if (DOM.summaryModal) {
                DOM.summaryModal.classList.add('hidden');
            }
        }

        // --- Event Listeners --- (Same as v1.8)
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Debug: DOMContentLoaded event fired.");
            
            // Initialize DOM elements
            if (!DOM.rulesModal || !DOM.closeRulesButton) {
                console.error("Debug: Modal elements not found!");
            } else {
                DOM.closeRulesButton.addEventListener('click', hideRulesModal);
            }
            
            if (DOM.startButton) {
                DOM.startButton.addEventListener('click', startGame);
            } else {
                console.error("Start button not found");
            }
            
            if (DOM.pauseButton) {
                DOM.pauseButton.addEventListener('click', togglePause);
                DOM.pauseButton.disabled = true;
            } else {
                console.error("Pause button not found");
            }
            
            if (DOM.closeSummaryButton) {
                DOM.closeSummaryButton.addEventListener('click', () => {
                    hideGameSummary();
                    resetGame();
                    startGame();
                });
            }
            
            // Initialize display
            updateGameTimerDisplay();
            updateScoreDisplay();
            updateMicStatus('idle');
        });

        /** Creates a new investor and adds it to the game area */
        function createInvestor() {
            console.log("Creating new investor...");
            if (investors.length >= MAX_INVESTORS) {
                console.log("Max investors reached:", investors.length);
                return;
            }
            const investorData = {
                id: Date.now(),
                element: document.createElement('div'),
                isBeingPitched: false,
                hasBeenPitched: false,
                boredomLevel: 0,
                pitchTimerId: null,
                boredomTimerId: null,
                boredomIncrementFactor: 0.2,
                pitchTimeLeft: PITCH_DURATION_SECONDS
            };
            
            // Use the correct class name 'investor' instead of 'character'
            investorData.element.className = 'investor';
            
            // Add padding for the timer and boredom bars
            const padding = 60; // Height of the investor element
            investorData.element.style.left = `${Math.random() * (DOM.gameArea.clientWidth - padding)}px`;
            investorData.element.style.top = `${Math.random() * (DOM.gameArea.clientHeight - padding)}px`;
            
            // Add timer and boredom meters
            investorData.element.innerHTML = `
                <div class="timer-bar-container">
                    <div class="timer-bar" style="width: 100%"></div>
                </div>
                <div class="boredom-bar-container">
                    <div class="boredom-bar" style="width: 0%"></div>
                </div>
                <span class="face">${INVESTOR_DEFAULT_FACE}</span>
            `;
            
            // Add click event listener with proper binding
            investorData.element.onclick = () => {
                if (!isGameRunning) {
                    showMessage("Game is not running!", true);
                    return;
                }
                if (isPaused) {
                    showMessage("Game is paused!", true);
                    return;
                }
                if (investorData.hasBeenPitched) {
                    showMessage("This investor has already been pitched to!", true);
                    return;
                }
                if (currentPitch) {
                    showMessage("Already pitching to another investor!", true);
                    return;
                }
                startPitch(investorData);
            };
            
            DOM.gameArea.appendChild(investorData.element);
            investors.push(investorData);
            console.log("Investor created. Total investors:", investors.length);
        }

        function copyShareMessage() {
            const shareMessage = document.getElementById('share-message');
            if (shareMessage) {
                navigator.clipboard.writeText(shareMessage.textContent)
                    .then(() => {
                        const button = shareMessage.nextElementSibling;
                        const originalText = button.textContent;
                        button.textContent = 'Copied!';
                        button.classList.add('bg-green-500', 'hover:bg-green-700');
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.classList.remove('bg-green-500', 'hover:bg-green-700');
                            button.classList.add('bg-blue-500', 'hover:bg-blue-700');
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Failed to copy text: ', err);
                    });
            }
        }

        function calculatePitch(audioData) {
            // Implement autocorrelation for pitch detection
            const correlations = new Float32Array(audioData.length);
            let maxCorrelation = 0;
            let foundPitch = 0;
            
            for (let lag = 0; lag < correlations.length; lag++) {
                let correlation = 0;
                for (let i = 0; i < correlations.length - lag; i++) {
                    correlation += audioData[i] * audioData[i + lag];
                }
                correlations[lag] = correlation;
                
                if (correlation > maxCorrelation) {
                    maxCorrelation = correlation;
                    foundPitch = lag;
                }
            }
            
            return {
                frequency: 44100 / foundPitch, // Sample rate / lag
                variation: calculateVariation(correlations)
            };
        }

        function calculateVolume(audioData) {
            // Calculate RMS volume
            const sum = audioData.reduce((acc, val) => acc + val * val, 0);
            const rms = Math.sqrt(sum / audioData.length);
            return 20 * Math.log10(rms); // Convert to dB
        }

        function calculateClarity(audioData) {
            // Analyze signal-to-noise ratio and spectral flatness
            let sumSquares = 0;
            let sumMagnitude = 0;
            
            for (let i = 0; i < audioData.length; i++) {
                sumSquares += audioData[i] * audioData[i];
                sumMagnitude += Math.abs(audioData[i]);
            }
            
            const rms = Math.sqrt(sumSquares / audioData.length);
            const average = sumMagnitude / audioData.length;
            
            // Calculate crest factor (peak-to-RMS ratio)
            const peakValue = Math.max(...audioData.map(Math.abs));
            const crestFactor = peakValue / rms;
            
            // Normalize to 0-1 range
            return Math.min(1, Math.max(0, (crestFactor - 1) / 4));
        }

        function analyzeRhythm(audioData) {
            // Analyze speech rhythm using energy envelope
            const frameSize = 1024;
            const hopSize = 512;
            const numFrames = Math.floor((audioData.length - frameSize) / hopSize);
            const energyEnvelope = new Float32Array(numFrames);
            
            // Calculate energy envelope
            for (let i = 0; i < numFrames; i++) {
                let sum = 0;
                for (let j = 0; j < frameSize; j++) {
                    sum += audioData[i * hopSize + j] * audioData[i * hopSize + j];
                }
                energyEnvelope[i] = sum / frameSize;
            }
            
            // Find peaks in energy envelope (syllables)
            const peaks = findPeaks(energyEnvelope);
            
            // Calculate rhythm regularity
            const intervals = [];
            for (let i = 1; i < peaks.length; i++) {
                intervals.push(peaks[i] - peaks[i - 1]);
            }
            
            // Calculate coefficient of variation of intervals
            const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
            const variance = intervals.reduce((a, b) => a + (b - mean) * (b - mean), 0) / intervals.length;
            const cv = Math.sqrt(variance) / mean;
            
            // Convert to rhythm score (0-1)
            return Math.max(0, Math.min(1, 1 - cv));
        }

        function calculatePacing(words) {
            const duration = PITCH_DURATION_SECONDS;
            const wordsPerMinute = (words.length / duration) * 60;
            
            // Score based on target range (120-160 WPM)
            if (wordsPerMinute < VOICE_ANALYSIS.clarity.minWordsPerMinute) {
                return wordsPerMinute / VOICE_ANALYSIS.clarity.minWordsPerMinute;
            } else if (wordsPerMinute > VOICE_ANALYSIS.clarity.maxWordsPerMinute) {
                return 1 - ((wordsPerMinute - VOICE_ANALYSIS.clarity.maxWordsPerMinute) / 
                          VOICE_ANALYSIS.clarity.maxWordsPerMinute);
            }
            return 1.0;
        }

        function analyzeStructure(transcript) {
            let score = 0;
            const elements = VOICE_ANALYSIS.semantics.structureElements;
            
            // Check for presence of each structural element
            elements.forEach(element => {
                const regex = new RegExp(`\\b${element}\\b|\\b${element}s\\b|\\b${element}ing\\b`, 'i');
                if (regex.test(transcript)) {
                    score += 1 / elements.length;
                }
            });
            
            return score;
        }

        function findTransitions(transcript) {
            let score = 0;
            const phrases = VOICE_ANALYSIS.semantics.transitionPhrases;
            
            // Count transition phrases
            phrases.forEach(phrase => {
                const regex = new RegExp(`\\b${phrase}\\b`, 'gi');
                const matches = transcript.match(regex) || [];
                score += matches.length * (1 / phrases.length);
            });
            
            return Math.min(1, score);
        }

        function detectEmphasis(transcript) {
            // Analyze sentence structure and punctuation
            const sentences = transcript.split(/[.!?]+/).filter(s => s.trim().length > 0);
            let score = 0;
            
            sentences.forEach(sentence => {
                // Check for emphasis patterns
                if (/^(what|how|why|when|where|who)\b/i.test(sentence)) score += 0.2;
                if (/!/g.test(sentence)) score += 0.15;
                if (/\b(most|best|key|critical|essential|crucial|vital)\b/i.test(sentence)) score += 0.1;
                if (/\b(imagine|consider|think about)\b/i.test(sentence)) score += 0.1;
            });
            
            return Math.min(1, score);
        }

        function findPeaks(array) {
            const peaks = [];
            const threshold = 0.1;
            
            for (let i = 1; i < array.length - 1; i++) {
                if (array[i] > threshold && 
                    array[i] > array[i-1] && 
                    array[i] > array[i+1]) {
                    peaks.push(i);
                }
            }
            
            return peaks;
        }

        function calculateVariation(array) {
            const mean = array.reduce((a, b) => a + b, 0) / array.length;
            const variance = array.reduce((a, b) => a + (b - mean) * (b - mean), 0) / array.length;
            return Math.sqrt(variance) / mean;
        }

    </script>

</body>
</html>


