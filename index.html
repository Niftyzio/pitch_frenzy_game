<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pitch Frenzy - Voice Input! (Stricter Analysis)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { font-family: sans-serif; }
      .character {
        width: 50px; height: 50px; border-radius: 50%; position: absolute; display: flex;
        align-items: center; justify-content: center; font-size: 1.5rem; cursor: pointer;
        transition: transform 0.2s ease, background-color 0.5s ease;
      }
      .character .face { display: inline-block; transition: transform 0.3s ease; }
      .character:hover { transform: scale(1.1); }
      .timer-bar-container, .boredom-bar-container {
        width: 50px; height: 5px; background-color: #e0e0e0; border-radius: 2.5px;
        overflow: hidden; position: absolute; left: 0;
      }
      .timer-bar-container { top: -10px; } .boredom-bar-container { top: -18px; }
      .timer-bar { width: 100%; background-color: #4caf50; height: 100%; border-radius: 2.5px; transition: width 0.5s linear; }
      .boredom-bar { width: 0%; background-color: #f44336; height: 100%; border-radius: 2.5px; transition: width 0.5s linear; }
      button:disabled { opacity: 0.5; cursor: not-allowed; }
      #mic-status svg { width: 1.25rem; height: 1.25rem; display: inline-block; vertical-align: middle; }
      .debug-warning { color: #eab308; background-color: #fffbeb; border: 1px solid #fde68a; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.875rem; margin-top: 0.5rem; text-align: center;}
      .api-error-warning { color: #dc2626; font-size: 0.875rem; margin-top: 0.5rem; }
      .keyword-feedback { font-size: 0.8rem; color: #6b7280; } /* gray-500 */
      #rules-modal li { margin-bottom: 0.5rem; }
      #rules-modal strong { color: #1d4ed8; }
      .feedback-indicator {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        font-size: 14px;
        max-width: 300px;
      }
      .feedback-indicator .metric {
        margin: 5px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .feedback-indicator .score {
        font-weight: bold;
        color: #4a90e2;
      }
      .warning {
        color: #e74c3c;
      }
      .success {
        color: #2ecc71;
      }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div id="rules-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg mx-4">
            <h2 class="text-2xl font-bold mb-4 text-center text-blue-600">How to Play Pitch Frenzy!</h2>
            <ul class="list-disc list-inside mb-6 text-gray-700">
                 <li><strong>Purpose:</strong> Practice your elevator pitch with mock investors.</li>
                 <li><strong>Goal:</strong> Successfully pitch to as many investors (üßê) as possible within the 3-minute time limit.</li>
                 <li><strong>Pitching:</strong> Click an investor to start. Speak clearly when the mic icon (ÔøΩÔøΩÔ∏è) turns red.</li>
                 <li><strong>Time Limit:</strong> Each investor only listens for 30 seconds (‚è≥).</li>
                 <li><strong>Boredom:</strong> Use relevant keywords ('market', 'growth', 'solution') to keep investors interested. Filler words ('um', 'like', 'hmm') or short pitches increase boredom (üü•).</li>
                 <li><strong>Failure (Pitch):</strong> If the boredom meter fills or the 30s timer runs out, the investor falls asleep (üò¥) and you fail that pitch.</li>
                 <li><strong>Failure (Game):</strong> The game ends when the main 3-minute timer runs out. Aim for the highest score!</li>
            </ul>
            <div class="text-center">
                <button id="close-rules-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow transition duration-150 ease-in-out">Got It!</button>
            </div>
        </div>
    </div>

    <div id="summary-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg mx-4">
            <h2 class="text-2xl font-bold mb-4 text-center text-blue-600">Pitch Frenzy Results!</h2>
            <div class="mb-6">
                <div class="text-center mb-4">
                    <p class="text-xl font-semibold">You successfully pitched to <span id="successful-pitches" class="text-green-600">0</span> investors!</p>
                    <p class="text-lg">Total Score: <span id="final-score" class="text-blue-600">0</span></p>
                </div>
                <div class="border-t border-gray-200 pt-4">
                    <h3 class="font-semibold mb-2">Performance Analysis:</h3>
                    <ul id="performance-stats" class="list-disc list-inside text-gray-700 space-y-2">
                    </ul>
                </div>
                <div class="border-t border-gray-200 pt-4 mt-4">
                    <h3 class="font-semibold mb-2">Improvement Tips:</h3>
                    <ul id="improvement-tips" class="list-disc list-inside text-gray-700 space-y-2">
                    </ul>
                </div>
                <div class="border-t border-gray-200 pt-4 mt-4">
                    <h3 class="font-semibold mb-2">Share Your Achievement:</h3>
                    <div class="bg-gray-50 p-3 rounded-lg text-center">
                        <p id="share-message" class="text-lg font-medium text-gray-800 mb-2">üéØ I pitched 0 investors and scored 0 points in Pitch Frenzy! Think you can beat my score? üöÄ #PitchFrenzy</p>
                        <button onclick="copyShareMessage()" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out">
                            Copy to Clipboard
                        </button>
                    </div>
                </div>
            </div>
            <div class="text-center">
                <button id="close-summary-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow transition duration-150 ease-in-out">Play Again</button>
            </div>
        </div>
    </div>

    <h1 class="text-3xl font-bold mb-4 text-blue-600">Pitch Frenzy! (Voice Enabled - Stricter Analysis)</h1>

    <div class="game-header flex justify-between items-center p-4 bg-white shadow-md">
        <div class="flex items-center space-x-4">
            <div class="flex items-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-500"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                <span class="font-semibold">Time Left:</span> <span id="game-timer" class="font-mono text-lg text-red-600">03:00</span>
            </div>
        </div>
        <div class="flex items-center space-x-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-green-500"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a2 2 0 0 1 1.79 1.11L15 5.88Z"/></svg>
             <span class="font-semibold">Score:</span> <span id="score" class="font-mono text-lg text-green-600">0</span>
        </div>
    </div>
    <div id="game-area" class="relative w-full max-w-4xl h-[60vh] bg-blue-100 rounded-lg shadow-inner overflow-hidden border-2 border-blue-300">
        <div id="founder" class="character bg-green-500" style="left: 50%; top: 85%; transform: translateX(-50%); cursor: default;">üòé</div>
    </div>
    <div class="mt-4 flex flex-col items-center w-full max-w-4xl">
         <div class="flex space-x-4">
            <button id="start-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow transition duration-150 ease-in-out">Start Game</button>
            <button id="pause-button" class="bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-2 px-6 rounded-lg shadow transition duration-150 ease-in-out">Pause</button>
         </div>
         <div class="flex items-center mt-3 space-x-4">
             <div id="mic-status" class="flex items-center justify-center w-10 h-10 rounded-full bg-gray-200"></div>
             <button id="pitch-now-button" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg shadow transition duration-150 ease-in-out hidden">Pitch Now!</button>
             <p id="message-area" class="h-6 text-gray-700 font-semibold"></p>
         </div>
         <p id="transcript-area" class="mt-1 h-10 text-sm text-gray-500 italic"></p>
         <div id="debug-warning-area" class="w-full max-w-md"></div>
    </div>

    <div id="feedbackIndicator" class="feedback-indicator hidden">
        <div class="metric">
            <span>Pitch Quality:</span>
            <span class="score" id="pitchScore">0</span>
        </div>
        <div class="metric">
            <span>Business Terms:</span>
            <span id="businessTerms">0</span>
        </div>
        <div id="realTimeFeedback" class="warning"></div>
    </div>

    <script>
        console.log("Script execution started.");

        // --- SVG Icons --- (Same as v1.7)
        const MIC_OFF_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="23"/><line x1="8" x2="16" y1="23" y2="23"/></svg>`;
        const MIC_ON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="23"/><line x1="8" x2="16" y1="23" y2="23"/></svg>`;

        // --- Keyword Definitions ---
        const POSITIVE_KEYWORDS = ["market", "growth", "revenue", "solution", "problem", "team", "traction", "unique", "disrupt", "value", "customer", "scale", "profit", "innovate", "strategy", "opportunity", "potential", "competitive", "advantage", "data", "users", "launch", "funding", "build", "develop"];
        // *** Added hmm, hmmm, err ***
        const NEGATIVE_KEYWORDS = ["um", "uh", "like", "basically", "actually", "really", "just", "stuff", "things", "guess", "kinda", "sorta", "hello", "hi", "hmm", "hmmm", "err"];
        const MIN_WORD_COUNT = 10;

        // --- Web Speech API Setup --- (Same as v1.7)
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        const isSpeechApiAvailable = !!SpeechRecognition;
        let currentPitchAnalysis = { score: 0, words: 0, positive: 0, negative: 0, boredomFactor: 0.2 }; // Store analysis results including factor

        // --- Game Configuration & State ---
        const GAME_DURATION_SECONDS = 180; // 3 minutes
        const PITCH_DURATION_SECONDS = 30;
        const MAX_INVESTORS = 12; // Increased from 8 to 12
        const INVESTOR_SPAWN_INTERVAL_MS = 3000; // Decreased from 5000 to 3000ms
        const VOICE_LISTEN_DURATION_MS = 10000;
        const DOM = {
            gameTimer: document.getElementById('game-timer'),
            scoreDisplay: document.getElementById('score-display'),
            micStatus: document.getElementById('mic-status'),
            transcriptArea: document.getElementById('transcript-area'),
            warningArea: document.getElementById('warning-area'),
            rulesModal: document.getElementById('rules-modal'),
            successfulPitchesDisplay: document.getElementById('successful-pitches'),
            finalScoreDisplay: document.getElementById('final-score'),
            performanceStats: document.getElementById('performance-stats'),
            improvementTips: document.getElementById('improvement-tips')
        };

        // Game state variables
        let isGameRunning = false;
        let gameTimeLeft = GAME_DURATION_SECONDS;
        let score = 0;
        let currentPitch = null;
        
        // Update initial display
        document.addEventListener('DOMContentLoaded', function() {
            if (DOM.gameTimer) DOM.gameTimer.textContent = "03:00";
            updateScoreDisplay();
        });

        function resetGame() {
            stopAllPitches();
            gameTimeLeft = GAME_DURATION_SECONDS;
            score = 0;
            currentPitch = null;
            isGameRunning = false;
            if (DOM.gameTimer) DOM.gameTimer.textContent = "03:00";
            updateScoreDisplay();
            clearAllInvestors();
            gameStats = createInitialGameStats();
        }

        // --- Functions --- (formatTime, updateGameTimerDisplay, updateScoreDisplay, showMessage, clearMessage, updateMicStatus, showWarning, clearWarning, showRulesModal, hideRulesModal - same as v1.8)
        function formatTime(totalSeconds) { const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
        function updateGameTimerDisplay() { DOM.gameTimer.textContent = formatTime(gameTimeLeft); }
        function updateScoreDisplay() { DOM.scoreDisplay.textContent = score; }
        function showMessage(msg, isError = false, persist = false) { if (!DOM.messageArea) { console.error("Debug: messageArea not found!"); return; } DOM.messageArea.textContent = msg; DOM.messageArea.style.color = isError ? '#dc2626' : '#374151'; if (!isError && !persist) { setTimeout(() => { if (DOM.messageArea.textContent === msg) DOM.messageArea.textContent = ''; }, 3000); } }
        function clearMessage() { if (DOM.messageArea) DOM.messageArea.textContent = ''; if (DOM.transcriptArea) DOM.transcriptArea.textContent = ''; }
        function updateMicStatus(status) {
            if (!DOM.micStatus) {
                console.error("Debug: micStatus element not found!");
                return;
            }
            console.log("Debug: Updating mic status to:", status);
            let svg = MIC_OFF_SVG;
            let colorClass = 'text-gray-400';
            let pitchButton = document.getElementById('pitch-now-button');
            
            switch (status) {
                case 'listening':
                    svg = MIC_ON_SVG;
                    colorClass = 'text-red-500 bg-red-100';
                    if (pitchButton) pitchButton.classList.remove('hidden');
                    break;
                case 'processing':
                    svg = MIC_ON_SVG;
                    colorClass = 'text-blue-500 bg-blue-100';
                    if (pitchButton) pitchButton.classList.add('hidden');
                    break;
                case 'error':
                    svg = MIC_OFF_SVG;
                    colorClass = 'text-red-500 bg-red-100';
                    if (pitchButton) pitchButton.classList.add('hidden');
                    break;
                case 'idle':
                default:
                    svg = MIC_OFF_SVG;
                    colorClass = 'text-gray-400 bg-gray-200';
                    if (pitchButton) pitchButton.classList.add('hidden');
                    break;
            }
            DOM.micStatus.innerHTML = svg;
            DOM.micStatus.className = `flex items-center justify-center w-10 h-10 rounded-full ${colorClass}`;
        }
        function showWarning(id, text, type = 'api-error') { if (!DOM.warningArea) return; const existing = document.getElementById(id); if (existing) existing.remove(); const warning = document.createElement('p'); warning.id = id; warning.textContent = text; warning.className = type === 'https' ? 'debug-warning' : 'api-error-warning'; DOM.warningArea.appendChild(warning); }
        function clearWarning(id) { const existing = document.getElementById(id); if (existing) existing.remove(); }
        function showRulesModal() { if (DOM.rulesModal) { DOM.rulesModal.classList.remove('hidden'); } }
        function hideRulesModal() { if (DOM.rulesModal) { DOM.rulesModal.classList.add('hidden'); } }

        function updateGameStats(pitchAnalysis, success) {
            gameStats.totalPitches++;
            if (success) gameStats.successfulPitches++;
            else gameStats.failedPitches++;
            
            gameStats.totalScore += pitchAnalysis.score;
            gameStats.averageScore = gameStats.totalScore / gameStats.totalPitches;

            // Track specific issues
            const wordsPerMinute = (pitchAnalysis.words / (pitchAnalysis.duration || 30)) * 60;
            if (wordsPerMinute < 100) gameStats.pitchAnalysis.tooSlow++;
            if (wordsPerMinute > 180) gameStats.pitchAnalysis.tooFast++;
            
            const fillerRatio = pitchAnalysis.negative / pitchAnalysis.words;
            if (fillerRatio > 0.15) gameStats.pitchAnalysis.highFillerWords++;
            
            const keywordDensity = pitchAnalysis.positive / pitchAnalysis.words;
            if (keywordDensity < 0.1) gameStats.pitchAnalysis.lowKeywordDensity++;
            
            if (pitchAnalysis.repetitionPenalty > 1) gameStats.pitchAnalysis.repetitivePhrases++;
            if (pitchAnalysis.maxConsecutiveFillerWords >= 3) gameStats.pitchAnalysis.consecutiveFillers++;

            // Store pitch quality metrics
            if (pitchAnalysis) {
                gameStats.pitchScores.push(pitchAnalysis.score);
                gameStats.avgPitchScore = gameStats.pitchScores.reduce((a, b) => a + b, 0) / gameStats.pitchScores.length;
            }
        }

        function showGameSummary() {
            // Update summary displays
            DOM.successfulPitchesDisplay.textContent = gameStats.successfulPitches;
            DOM.finalScoreDisplay.textContent = score;

            // Update share message
            const shareMessage = document.getElementById('share-message');
            if (shareMessage) {
                shareMessage.textContent = `üéØ I pitched ${gameStats.totalPitches} investors and scored ${score} points in Pitch Frenzy! Think you can beat my score? üöÄ #PitchFrenzy`;
            }

            // Clear previous stats
            DOM.performanceStats.innerHTML = '';
            DOM.improvementTips.innerHTML = '';

            // Add performance statistics
            const stats = [
                `Success Rate: ${((gameStats.successfulPitches / gameStats.totalPitches) * 100).toFixed(1)}%`,
                `Average Pitch Score: ${gameStats.averageScore.toFixed(1)}`,
                `Total Pitches Attempted: ${gameStats.totalPitches}`
            ];
            stats.forEach(stat => {
                const li = document.createElement('li');
                li.textContent = stat;
                DOM.performanceStats.appendChild(li);
            });

            // Generate improvement tips based on statistics
            const tips = [];
            
            if (gameStats.pitchAnalysis.tooSlow > gameStats.totalPitches / 2) {
                tips.push("Try speaking a bit faster - aim for 100-180 words per minute");
            }
            if (gameStats.pitchAnalysis.tooFast > gameStats.totalPitches / 2) {
                tips.push("Slow down your speaking pace for better clarity");
            }
            if (gameStats.pitchAnalysis.highFillerWords > gameStats.totalPitches / 2) {
                tips.push("Reduce filler words like 'um', 'like', and 'hmm'");
            }
            if (gameStats.pitchAnalysis.lowKeywordDensity > gameStats.totalPitches / 2) {
                tips.push("Include more business keywords like 'market', 'growth', and 'solution'");
            }
            if (gameStats.pitchAnalysis.repetitivePhrases > gameStats.totalPitches / 2) {
                tips.push("Avoid repeating the same phrases multiple times");
            }
            if (gameStats.pitchAnalysis.consecutiveFillers > gameStats.totalPitches / 2) {
                tips.push("Try to avoid using multiple filler words in a row");
            }

            // Add general tips if no specific issues were identified
            if (tips.length === 0) {
                tips.push("Great job! Keep practicing to maintain your skills");
                tips.push("Try to vary your pitch structure for different investors");
            }

            tips.forEach(tip => {
                const li = document.createElement('li');
                li.textContent = tip;
                DOM.improvementTips.appendChild(li);
            });

            // Show the summary modal
            DOM.summaryModal.classList.remove('hidden');
        }

        function hideGameSummary() {
            DOM.summaryModal.classList.add('hidden');
            // Reset game stats for next game
            gameStats = {
                totalPitches: 0,
                successfulPitches: 0,
                failedPitches: 0,
                averageScore: 0,
                totalScore: 0,
                pitchAnalysis: {
                    tooSlow: 0,
                    tooFast: 0,
                    highFillerWords: 0,
                    lowKeywordDensity: 0,
                    repetitivePhrases: 0,
                    consecutiveFillers: 0
                },
                pitchScores: [],
                avgPitchScore: 0
            };
        }

        /** Analyzes transcript for keywords and length */
        function analyzePitch(transcript) {
            const analysis = {
                score: 0,
                feedback: [],
                hesitationCount: 0,
                businessTerms: 0
            };

            // Check for hesitations and filler words
            const hesitations = transcript.match(/\b(um|uh|er|like|you know|sort of|kind of|basically)\b/gi) || [];
            analysis.hesitationCount = hesitations.length;
            
            // Detect pauses (represented by ..., multiple spaces, or punctuation)
            const pauses = transcript.match(/\.{3,}|\s{2,}|[,.!?]\s+[,.!?]/g) || [];
            
            // Penalize for hesitations and excessive pauses
            analysis.score -= (hesitations.length * 0.5);
            analysis.score -= (pauses.length * 0.3);
            
            if (hesitations.length > 2) {
                analysis.feedback.push("Try to reduce filler words and hesitations");
            }

            // Check for business/pitch relevant terms
            const businessTerms = [
                'market', 'growth', 'revenue', 'solution', 'problem', 'customer',
                'business', 'product', 'service', 'value', 'innovation', 'strategy',
                'opportunity', 'competitive', 'scalable', 'investment', 'return',
                'profit', 'market share', 'target audience', 'unique selling proposition'
            ];

            const foundTerms = businessTerms.filter(term => 
                new RegExp('\\b' + term + '\\b', 'i').test(transcript)
            );
            
            analysis.businessTerms = foundTerms.length;
            analysis.score += (foundTerms.length * 0.8);

            // Check for pitch structure elements
            const structureElements = {
                problem: /\b(problem|challenge|issue|pain point)\b/i,
                solution: /\b(solution|solve|address|fix|resolve)\b/i,
                market: /\b(market|audience|customer|user|demographic)\b/i,
                value: /\b(value|benefit|advantage|return|roi)\b/i
            };

            Object.entries(structureElements).forEach(([element, regex]) => {
                if (regex.test(transcript)) {
                    analysis.score += 1;
                }
            });

            // Normalize score between -5 and 5
            analysis.score = Math.max(-5, Math.min(5, analysis.score));

            return analysis;
        }

        /** Determines boredom factor based on pitch analysis */
        function calculateBoredomFactor(analysis) {
            let factor = 0.1; // Default: Very Fast
            let reason = "(Default/Error)";

            // Base factor from score
            let scoreFactor = 0.1;
            if (analysis.score <= 0) {
                scoreFactor = 0.15;
            } else if (analysis.score <= 2) {
                scoreFactor = 0.6;
            } else {
                scoreFactor = 0.9;
            }

            // Speaking pace penalty
            const wordsPerMinute = (analysis.words / (analysis.duration || 30)) * 60;
            let paceFactor = 1.0;
            if (wordsPerMinute < 100) {
                paceFactor = 1.3; // Too slow
            } else if (wordsPerMinute > 180) {
                paceFactor = 1.2; // Too fast
            }

            // Keyword density bonus
            const keywordDensity = analysis.positive / analysis.words;
            let densityFactor = 1.0;
            if (keywordDensity < 0.1) {
                densityFactor = 1.4; // Very few keywords
            } else if (keywordDensity > 0.3) {
                densityFactor = 0.8; // Good keyword density
            }

            // Filler word penalty
            const fillerRatio = analysis.negative / analysis.words;
            let fillerFactor = 1.0;
            if (fillerRatio > 0.15) {
                fillerFactor = 1.5; // Too many filler words
            } else if (fillerRatio > 0.1) {
                fillerFactor = 1.3;
            }

            // Consecutive filler words penalty
            let consecutiveFillerFactor = 1.0;
            if (analysis.maxConsecutiveFillerWords >= 3) {
                consecutiveFillerFactor = 1.4; // Heavy penalty for 3+ consecutive filler words
            } else if (analysis.maxConsecutiveFillerWords >= 2) {
                consecutiveFillerFactor = 1.2;
            }

            // Repetition penalty
            let repetitionFactor = 1.0;
            if (analysis.repetitionPenalty > 1) {
                repetitionFactor = 1.3; // Significant penalty for repetitive phrases
            } else if (analysis.repetitionPenalty > 0.5) {
                repetitionFactor = 1.2;
            }

            // Progressive difficulty
            const gameProgress = Math.min(1, analysis.score / 5);
            const difficultyFactor = 1 + (gameProgress * 0.3); // Up to 30% harder

            // Calculate final factor
            factor = scoreFactor * paceFactor * densityFactor * fillerFactor * consecutiveFillerFactor * repetitionFactor * difficultyFactor;
            
            // Cap the factor between 0.1 and 1.5
            factor = Math.max(0.1, Math.min(1.5, factor));

            reason = `(Score:${scoreFactor.toFixed(2)} Pace:${paceFactor.toFixed(2)} Density:${densityFactor.toFixed(2)} Filler:${fillerFactor.toFixed(2)} Consec:${consecutiveFillerFactor.toFixed(2)} Rep:${repetitionFactor.toFixed(2)} Difficulty:${difficultyFactor.toFixed(2)})`;
            console.log(`Boredom Factor: ${factor.toFixed(2)} ${reason}`);
            
            return factor;
        }

        /** Starts the pitch: initiates timers and voice recognition */
        function startPitch(investorData) {
            console.log("Debug: startPitch called.");
            if (!isGameRunning || isPaused || isListening || investorData.isBeingPitched || investorData.hasBeenPitched || currentPitch) { return; }

            currentPitch = investorData;
            investorData.isBeingPitched = true;
            investorData.element.style.outline = '3px solid blue';
            // Reset pitch analysis state for this investor
            investorData.boredomIncrementFactor = 0.15;
            investorData.pitchScore = 0;
            investorData.pitchTimeLeft = PITCH_DURATION_SECONDS; // Initialize the timer to 30 seconds
            currentPitchAnalysis = analyzePitch(transcript);

            clearMessage();

            // Start 30s Pitch Timer
            const timerBar = investorData.element.querySelector('.timer-bar');
            if(timerBar) timerBar.style.width = '100%';
            
            investorData.pitchTimerId = setInterval(() => {
                if (isPaused || !investorData.isBeingPitched) return;
                investorData.pitchTimeLeft--;
                const timerWidth = (investorData.pitchTimeLeft / PITCH_DURATION_SECONDS) * 100;
                if(timerBar) timerBar.style.width = `${Math.max(0, timerWidth)}%`;
                
                // End pitch if time runs out
                if (investorData.pitchTimeLeft <= 0) {
                    endPitch(investorData, false, "Time's up!");
                }
            }, 1000);

            // Handle Voice Input
            if (isSpeechApiAvailable) {
                console.log("Debug: Speech API is available, attempting to start recognition.");
                showMessage("Pitch Now!");
                updateMicStatus('listening');
                isListening = true;
                DOM.transcriptArea.textContent = 'Listening...';
                
                try {
                    recognition = new SpeechRecognition();
                    recognition.continuous = true; // Changed to true to catch pauses
                    recognition.interimResults = true; // Changed to true to detect pauses
                    recognition.lang = 'en-US';
                    
                    let lastSpeechTime = Date.now();
                    let pauseCheckInterval = setInterval(() => {
                        if (isListening && Date.now() - lastSpeechTime > 1500) { // Reduced from 2000ms to 1500ms
                            console.log("Detected pause in speech");
                            investorData.boredomLevel += 15; // Increased from 5 to 15
                            const boredomBar = investorData.element.querySelector('.boredom-bar');
                            if(boredomBar) boredomBar.style.width = `${Math.min(100, investorData.boredomLevel)}%`;
                            
                            if (investorData.boredomLevel >= 100) {
                                clearInterval(pauseCheckInterval);
                                endPitch(investorData, false, "Lost interest - too many pauses!");
                            }
                        }
                    }, 500);

                    recognition.onresult = (event) => {
                        lastSpeechTime = Date.now(); // Update last speech time
                        const transcript = Array.from(event.results)
                            .map(result => result[0].transcript)
                            .join(' ');
                        
                        console.log('Speech detected:', transcript);
                        currentPitchAnalysis = analyzePitch(transcript);
                        
                        // Increase boredom more rapidly for consecutive filler words
                        if (currentPitchAnalysis.maxConsecutiveFillerWords >= 2) {
                            investorData.boredomLevel += currentPitchAnalysis.maxConsecutiveFillerWords * 10;
                            const boredomBar = investorData.element.querySelector('.boredom-bar');
                            if(boredomBar) boredomBar.style.width = `${Math.min(100, investorData.boredomLevel)}%`;
                            
                            if (investorData.boredomLevel >= 100) {
                                endPitch(investorData, false, "Lost interest - too many filler words!");
                                return;
                            }
                        }

                        investorData.pitchScore = currentPitchAnalysis.score;
                        investorData.boredomIncrementFactor = calculateBoredomFactor(currentPitchAnalysis);
                        
                        let feedback = `Heard: "${transcript.substring(0, 40)}..." `;
                        feedback += `<span class="keyword-feedback">(Words: ${currentPitchAnalysis.words}, Score: ${currentPitchAnalysis.score} [+${currentPitchAnalysis.positive}/-${currentPitchAnalysis.negative}])</span>`;
                        DOM.transcriptArea.innerHTML = feedback;
                    };

                    recognition.onend = () => {
                        clearInterval(pauseCheckInterval);
                        console.log("Speech recognition ended.");
                        isListening = false;
                        updateMicStatus('idle');
                        if (!investorData.boredomTimerId && investorData.isBeingPitched) {
                            startBoredomTimer(investorData);
                        }
                        recognition = null;
                    };

                    recognition.start();
                    console.log("Debug: recognition.start() called.");
                } catch (e) {
                    console.error("Error starting recognition:", e);
                    showMessage("Error starting voice recognition", true);
                    updateMicStatus('error');
                    isListening = false;
                    if (!investorData.boredomTimerId && investorData.isBeingPitched) {
                        startBoredomTimer(investorData);
                    }
                }
            } else {
                console.log("Debug: Speech API not available path in startPitch.");
                showMessage("Voice input not supported by browser.", true, true);
                investorData.boredomIncrementFactor = 0.1;
                startBoredomTimer(investorData);
            }
        }

        /** Starts the boredom timer using the calculated factor */
        function startBoredomTimer(investorData) {
             if (!investorData || !investorData.isBeingPitched || investorData.boredomTimerId) return;
             const boredomBar = investorData.element.querySelector('.boredom-bar');
             const boredomInterval = 200;
             // Make base boredom increase 3x faster
             const boredomIncrement = (100 / (PITCH_DURATION_SECONDS * (1000 / boredomInterval) * investorData.boredomIncrementFactor)) * 3;
             console.log(`Starting boredom timer. Factor: ${investorData.boredomIncrementFactor.toFixed(2)}, Increment: ${boredomIncrement.toFixed(3)}`);

             investorData.boredomTimerId = setInterval(() => {
                 if (!investorData.isBeingPitched || isPaused) return;
                 
                 // Add extra boredom for consecutive filler words
                 if (currentPitchAnalysis.maxConsecutiveFillerWords >= 2) {
                     investorData.boredomLevel += currentPitchAnalysis.maxConsecutiveFillerWords * 20; // Doubled from 10 to 20
                 }
                 
                 // Add extra boredom for high filler word ratio
                 const fillerRatio = currentPitchAnalysis.negative / currentPitchAnalysis.words;
                 if (fillerRatio > 0.15) {
                     investorData.boredomLevel += 10; // Added penalty for high filler ratio
                 }

                 investorData.boredomLevel += boredomIncrement;
                 if(boredomBar) boredomBar.style.width = `${Math.min(100, investorData.boredomLevel)}%`;

                 // Success Condition - stricter requirements
                 if (investorData.pitchTimeLeft <= PITCH_DURATION_SECONDS - 5) { // Changed from 8 to 5 seconds
                     const baseSuccessChance = 0.12; // Increased from 0.08 to allow quicker success
                     const scoreBonus = (investorData.pitchScore > 0) ? Math.min(0.2, investorData.pitchScore * 0.08) : 0;
                     const boredomFactor = (1 - (investorData.boredomLevel / 100)); // Changed from 125 to 100
                     const successChance = Math.max(0.01, (baseSuccessChance + scoreBonus) * boredomFactor);

                     if (Math.random() < successChance && investorData.boredomLevel < 75) { // Changed from 90 to 75
                         endPitch(investorData, true, "Great pitch!");
                         return;
                     }
                 }

                 // Failure Condition - happens sooner
                 if (investorData.boredomLevel >= 100) {
                     endPitch(investorData, false, "Lost interest!");
                 }
             }, boredomInterval);
        }

        // --- Other Functions (endPitch, removeInvestor, endGame, startGame, togglePause) ---
        // Modify endPitch function to track statistics
        function endPitch(investorData, success, message) {
            if (!investorData || !investorData.isBeingPitched) return;
            stopRecognition();
            clearInterval(investorData.pitchTimerId);
            clearInterval(investorData.boredomTimerId);
            investorData.pitchTimerId = null;
            investorData.boredomTimerId = null;
            investorData.isBeingPitched = false;
            investorData.hasBeenPitched = true;
            currentPitch = null;
            investorData.element.style.outline = 'none';
            const faceSpan = investorData.element.querySelector('.face');
            if (faceSpan) faceSpan.style.transform = 'rotateY(0deg)';
            
            // Update game statistics
            updateGameStats(currentPitchAnalysis, success);
            
            if (success) {
                score++;
                updateScoreDisplay();
                showMessage("üëç Great pitch! Click another investor to continue.", false);
                if (faceSpan) faceSpan.textContent = 'üëç';  // Show thumbs up
                investorData.element.style.backgroundColor = '#4ade80';
                setTimeout(() => removeInvestor(investorData), 2000);  // Increased from 1500 to 2000
            } else {
                if (isGameRunning) {
                    // Check if failure was due to boredom or time
                    const failMessage = message.includes("Lost interest") ? 
                        "üëé Bored! Click another investor to try again." : 
                        "‚è∞ Time's up! Click another investor to try again.";
                    showMessage(failMessage, true);
                }
                if (faceSpan) faceSpan.textContent = message.includes("Lost interest") ? 'üëé' : '‚è∞';  // Show thumbs down for boredom, clock for timeout
                investorData.element.style.backgroundColor = '#f87171';
                setTimeout(() => removeInvestor(investorData), 2000);
            }
            setTimeout(() => {
                if (DOM.transcriptArea) DOM.transcriptArea.innerHTML = '';
            }, 1500);
        }
        function removeInvestor(investorData) {
            console.log("Removing investor...");
            if (investorData.pitchTimerId) clearInterval(investorData.pitchTimerId);
            if (investorData.boredomTimerId) clearInterval(investorData.boredomTimerId);
            if (investorData.element && investorData.element.parentNode === DOM.gameArea) {
                DOM.gameArea.removeChild(investorData.element);
            }
            investors = investors.filter(inv => inv.id !== investorData.id);
            console.log("Investor removed. Remaining investors:", investors.length);
            if (isGameRunning && !isPaused && investors.length < MAX_INVESTORS / 2) {
                console.log("Scheduling new investor creation...");
                setTimeout(createInvestor, 1000);
            }
        }
        function endGame() {
            stopRecognition();
            isGameRunning = false;
            isPaused = false;
            clearInterval(gameIntervalId);
            clearInterval(investorSpawnIntervalId);
            gameIntervalId = null;
            investorSpawnIntervalId = null;
            if (currentPitch && currentPitch.isBeingPitched) {
                endPitch(currentPitch, false, "Game Over!");
            }
            currentPitch = null;
            investors.forEach(inv => {
                if(inv.element) inv.element.style.cursor = 'default';
            });
            showMessage(`Game Over! Final Score: ${score}`, false, true);
            DOM.startButton.disabled = false;
            DOM.pauseButton.disabled = true;
            DOM.pauseButton.textContent = 'Pause';
            DOM.pauseButton.classList.remove('bg-green-500', 'hover:bg-green-700');
            DOM.pauseButton.classList.add('bg-yellow-500', 'hover:bg-yellow-700');
            DOM.startButton.textContent = "Play Again?";
            updateMicStatus('idle');
            
            // Show the game summary
            showGameSummary();
        }
        function startGame() { console.log("Debug: startGame called."); if (isGameRunning) return; if (!rulesShown) { showRulesModal(); rulesShown = true; return; } score = 0; gameTimeRemaining = GAME_DURATION_SECONDS; isGameRunning = true; isPaused = false; currentPitch = null; updateScoreDisplay(); updateGameTimerDisplay(); DOM.startButton.disabled = true; DOM.pauseButton.disabled = false; DOM.pauseButton.textContent = 'Pause'; DOM.pauseButton.classList.remove('bg-green-500', 'hover:bg-green-700'); DOM.pauseButton.classList.add('bg-yellow-500', 'hover:bg-yellow-700'); clearMessage(); updateMicStatus('idle'); clearWarning('https-warning'); clearWarning('speech-api-warning'); if (window.location.protocol !== 'https:') { console.warn("Debug: Page is not loaded over HTTPS."); showWarning('https-warning', 'Warning: Page is not HTTPS. Microphone access might be blocked by the browser.', 'https'); } else { console.log("Debug: Page is loaded over HTTPS."); } if (!isSpeechApiAvailable) { console.warn("Debug: Speech API IS NOT available."); showWarning('speech-api-warning', "Voice input not supported by browser.", 'api-error'); } else { console.log("Debug: Speech API IS available."); } investors.forEach(inv => { if (inv.element && inv.element.parentNode) inv.element.parentNode.removeChild(inv.element); }); investors = []; gameIntervalId = setInterval(() => { gameTimeRemaining--; updateGameTimerDisplay(); if (gameTimeRemaining <= 0) endGame(); }, 1000); for (let i = 0; i < MAX_INVESTORS / 2; i++) createInvestor(); investorSpawnIntervalId = setInterval(createInvestor, INVESTOR_SPAWN_INTERVAL_MS); }
        function togglePause() {
            if (!isGameRunning) return;
            
            isPaused = !isPaused;
            console.log("Game paused:", isPaused);
            
            if (isPaused) {
                // Pause game
                stopRecognition();
                clearInterval(gameIntervalId);
                clearInterval(investorSpawnIntervalId);
                
                // Stop all active timers
                investors.forEach(inv => {
                    if (inv.pitchTimerId) clearInterval(inv.pitchTimerId);
                    if (inv.boredomTimerId) clearInterval(inv.boredomTimerId);
                });
                
                gameIntervalId = null;
                investorSpawnIntervalId = null;
                
                // Update UI
                DOM.pauseButton.textContent = 'Resume';
                DOM.pauseButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-700');
                DOM.pauseButton.classList.add('bg-green-500', 'hover:bg-green-700');
                showMessage('Game Paused');
            } else {
                if (gameTimeRemaining > 0) {
                    // Resume game timer
                    gameIntervalId = setInterval(() => {
                        gameTimeRemaining--;
                        updateGameTimerDisplay();
                        if (gameTimeRemaining <= 0) endGame();
                    }, 1000);
                    
                    // Resume investor spawning
                    investorSpawnIntervalId = setInterval(createInvestor, INVESTOR_SPAWN_INTERVAL_MS);
                    
                    // Resume active pitch timers
                    investors.forEach(inv => {
                        if (inv.isBeingPitched) {
                            // Resume pitch timer
                            inv.pitchTimerId = setInterval(() => {
                                if (isPaused || !inv.isBeingPitched) return;
                                inv.pitchTimeLeft--;
                                const timerWidth = (inv.pitchTimeLeft / PITCH_DURATION_SECONDS) * 100;
                                const timerBar = inv.element.querySelector('.timer-bar');
                                if(timerBar) timerBar.style.width = `${Math.max(0, timerWidth)}%`;
                                
                                if (inv.pitchTimeLeft <= 0) {
                                    endPitch(inv, false, "Time's up!");
                                }
                            }, 1000);
                            
                            // Resume boredom timer
                            startBoredomTimer(inv);
                        }
                    });
                    
                    // Update UI
                    DOM.pauseButton.textContent = 'Pause';
                    DOM.pauseButton.classList.remove('bg-green-500', 'hover:bg-green-700');
                    DOM.pauseButton.classList.add('bg-yellow-500', 'hover:bg-yellow-700');
                    showMessage('Game Resumed');
                } else {
                    isPaused = true;
                    showMessage('Cannot resume, time is up!', true);
                }
            }
        }

        /** Stop speech recognition */
        function stopRecognition() {
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.error("Error stopping recognition:", e);
                }
                recognition = null;
            }
            isListening = false;
            updateMicStatus('idle');
        }

        // --- Event Listeners --- (Same as v1.8)
        document.addEventListener('DOMContentLoaded', () => { console.log("Debug: DOMContentLoaded event fired."); if (!DOM.rulesModal || !DOM.closeRulesButton) { console.error("Debug: Modal elements not found!"); } else { DOM.closeRulesButton.addEventListener('click', hideRulesModal); } if(DOM.startButton) DOM.startButton.addEventListener('click', startGame); else console.error("Start button not found"); if(DOM.pauseButton) DOM.pauseButton.addEventListener('click', togglePause); else console.error("Pause button not found"); updateGameTimerDisplay(); updateScoreDisplay(); if(DOM.pauseButton) DOM.pauseButton.disabled = true; updateMicStatus('idle'); if (DOM.closeSummaryButton) { DOM.closeSummaryButton.addEventListener('click', () => { hideGameSummary(); startGame(); }); } });

        /** Creates a new investor and adds it to the game area */
        function createInvestor() {
            console.log("Creating new investor...");
            if (investors.length >= MAX_INVESTORS) {
                console.log("Max investors reached:", investors.length);
                return;
            }
            const investorData = {
                id: Date.now(),
                element: document.createElement('div'),
                isBeingPitched: false,
                hasBeenPitched: false,
                boredomLevel: 0,
                pitchTimerId: null,
                boredomTimerId: null,
                boredomIncrementFactor: 0.2
            };
            investorData.element.className = 'character';
            investorData.element.style.left = `${Math.random() * (DOM.gameArea.clientWidth - 50)}px`;
            investorData.element.style.top = `${Math.random() * (DOM.gameArea.clientHeight - 50)}px`;
            investorData.element.style.backgroundColor = '#f3f4f6';
            
            // Add timer and boredom meters
            investorData.element.innerHTML = `
                <div class="timer-bar-container">
                    <div class="timer-bar" style="width: 100%"></div>
                </div>
                <div class="boredom-bar-container">
                    <div class="boredom-bar" style="width: 0%"></div>
                </div>
                <span class="face">${INVESTOR_DEFAULT_FACE}</span>
            `;
            
            investorData.element.addEventListener('click', () => startPitch(investorData));
            DOM.gameArea.appendChild(investorData.element);
            investors.push(investorData);
            console.log("Investor created. Total investors:", investors.length);
        }

        function updateFeedbackDisplay(analysis) {
            const feedbackIndicator = document.getElementById('feedbackIndicator');
            const pitchScore = document.getElementById('pitchScore');
            const businessTerms = document.getElementById('businessTerms');
            const realTimeFeedback = document.getElementById('realTimeFeedback');
            
            feedbackIndicator.classList.remove('hidden');
            pitchScore.textContent = analysis.score.toFixed(1);
            businessTerms.textContent = analysis.businessTerms;
            
            // Show real-time feedback
            if (analysis.hesitationCount > 2) {
                realTimeFeedback.textContent = "Try to reduce filler words";
                realTimeFeedback.className = "warning";
            } else if (analysis.businessTerms < 2) {
                realTimeFeedback.textContent = "Include more business terms";
                realTimeFeedback.className = "warning";
            } else {
                realTimeFeedback.textContent = "Good flow!";
                realTimeFeedback.className = "success";
            }
        }

        // Update the processTranscript function to include real-time feedback
        function processTranscript(transcript) {
            if (!currentPitch || !isGameRunning) return;
            
            const analysis = analyzePitch(transcript);
            updateFeedbackDisplay(analysis);
            currentPitchAnalysis = analysis;
            
            // Update the investor's boredom based on the pitch quality
            const boredomModifier = Math.max(0.5, 1 - (analysis.score / 10));
            currentPitch.boredomIncrementFactor = BOREDOM_INCREMENT * boredomModifier;
        }

        function copyShareMessage() {
            const shareMessage = document.getElementById('share-message');
            if (shareMessage) {
                navigator.clipboard.writeText(shareMessage.textContent)
                    .then(() => {
                        const button = shareMessage.nextElementSibling;
                        const originalText = button.textContent;
                        button.textContent = 'Copied!';
                        button.classList.add('bg-green-500', 'hover:bg-green-700');
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.classList.remove('bg-green-500', 'hover:bg-green-700');
                            button.classList.add('bg-blue-500', 'hover:bg-blue-700');
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Failed to copy text: ', err);
                    });
            }
        }

    </script>

</body>
</html>


